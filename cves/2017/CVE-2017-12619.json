{"Modified":"2019-04-30T14:54:00","Published":"2019-04-23T15:29:00","access":{"authentication":"NONE","complexity":"MEDIUM","vector":"NETWORK"},"assigner":"cve@mitre.org","capec":[{"id":"39","name":"Manipulating Opaque Client-based Data Tokens","prerequisites":"An attacker already has some access to the system or can steal the client based data tokens from another user who has access to the system. For an Attacker to viably execute this attack, some data (later interpreted by the application) must be held client-side in a way that can be manipulated without detection. This means that the data or tokens are not CRCd as part of their value or through a separate meta-data store elsewhere.","related_weakness":["233","285","302","315","353","384","472","539","565"],"solutions":"One solution to this problem is to protect encrypted data with a CRC of some sort. If knowing who last manipulated the data is important, then using a cryptographic \"message authentication code\" (or hMAC) is prescribed. However, this guidance is not a panacea. In particular, any value created by (and therefore encrypted by) the client, which itself is a \"malicious\" value, all the protective cryptography in the world can't make the value 'correct' again. Put simply, if the client has control over the whole process of generating and encoding the value, then simply protecting its integrity doesn't help. Make sure to protect client side authentication tokens for confidentiality (encryption) and integrity (signed hash) Make sure that all session tokens use a good source of randomness Perform validation on the server side to make sure that client side data tokens are consistent with what is expected.","summary":"In circumstances where an application holds important data client-side in tokens (cookies, URLs, data files, and so forth) that data can be manipulated. If client or server-side application components reinterpret that data as authentication tokens or data (such as store item pricing or wallet information) then even opaquely manipulating that data may bear fruit for an Attacker. In this pattern an attacker undermines the assumption that client side tokens have been adequately protected from tampering through use of encryption or obfuscation."},{"id":"61","name":"Session Fixation","prerequisites":"Session identifiers that remain unchanged when the privilege levels change. Permissive session management mechanism that accepts random user-generated session identifiers Predictable session identifiers","related_weakness":["361","384","664","732"],"solutions":"Use a strict session management mechanism that only accepts locally generated session identifiers: This prevents attackers from fixating session identifiers of their own choice. Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes. Use session identifiers that are difficult to guess or brute-force: One way for the attackers to obtain valid session identifiers is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult.","summary":"The attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. Once the user successfully authenticates to the target software, the attacker uses the (now privileged) session identifier in their own transactions. This attack leverages the fact that the target software either relies on client-generated session identifiers or maintains the same session identifiers after privilege elevation."},{"id":"21","name":"Exploitation of Trusted Credentials","prerequisites":"Server software must rely on weak session IDs proof and/or verification schemes","related_weakness":["290","302","346","384","539","6","602","642","664"],"solutions":"Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit. Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens. Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted. Design: Use strong session identifiers that are protected in transit and at rest. Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated. Implementation: Verify of authenticity of all session IDs at runtime.","summary":"Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes \"trust\" other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system."},{"id":"59","name":"Session Credential Falsification through Prediction","prerequisites":"The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are predictable. For example, the session IDs are generated using predictable information (e.g., time).","related_weakness":["200","285","290","330","331","346","384","488","539","6","693","719"],"solutions":"Use a strong source of randomness to generate a session ID. Use adequate length session IDs Do not use information available to the user in order to generate session ID (e.g., time). Ideas for creating random numbers are offered by Eastlake [RFC1750] Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.","summary":"This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking."},{"id":"196","name":"Session Credential Falsification through Forging","prerequisites":"The targeted application must use session credentials to identify legitimate users. Session identifiers that remains unchanged when the privilege levels change. Predictable session identifiers.","related_weakness":["384","664"],"solutions":"Implementation: Use session IDs that are difficult to guess or brute-force: One way for the attackers to obtain valid session IDs is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult. Implementation: Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes.","summary":"An attacker creates a false but functional session credential in order to gain or usurp access to a service. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. If an attacker is able to forge valid session credentials they may be able to bypass authentication or piggy-back off some other authenticated user's session. This attack differs from Reuse of Session IDs and Session Sidejacking attacks in that in the latter attacks an attacker uses a previous or existing credential without modification while, in a forging attack, the attacker must create their own credential, although it may be based on previously observed credentials."},{"id":"31","name":"Accessing/Intercepting/Modifying HTTP Cookies","prerequisites":"Target server software must be a HTTP daemon that relies on cookies. The cookies must contain sensitive information. The adversary must be able to make HTTP requests to the server, and the cookie must be contained in the reply.","related_weakness":["113","20","302","311","315","384","472","539","565","602","642","724"],"solutions":"Design: Use input validation for cookies Design: Generate and validate MAC for cookies Implementation: Use SSL/TLS to protect cookie in transit Implementation: Ensure the web server implements all relevant security patches, many exploitable buffer overflows are fixed in patches issued for the software.","summary":"This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems. There are several different forms of this attack. The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein. The second form involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the adversary to impersonate the remote user/session. The third form is when the cookie's content is modified by the adversary before it is sent back to the server. Here the adversary seeks to convince the target server to operate on this falsified information."},{"id":"60","name":"Reusing Session IDs (aka Session Replay)","prerequisites":"The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are not well protected from session theft.","related_weakness":["200","285","290","294","346","384","488","539","664","732"],"solutions":"Always invalidate a session ID after the user logout. Setup a session time out for the session IDs. Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack. Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker. Encrypt the session data associated with the session ID. Use multifactor authentication.","summary":"This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay."}],"cvss":5.8,"cvss-time":"2019-04-30T14:54:00","cvss-vector":"AV:N/AC:M/Au:N/C:P/I:P/A:N","cwe":"CWE-384","id":"CVE-2017-12619","impact":{"availability":"NONE","confidentiality":"PARTIAL","integrity":"PARTIAL"},"last-modified":"2019-04-30T14:54:00","references":["http://www.openwall.com/lists/oss-security/2019/04/23/1","http://www.securityfocus.com/bid/108050","https://lists.apache.org/thread.html/ff6b995a5a3ba8db4d6b14b4d9dd487e7bf2e3bdd5b375b64a25fd06@%3Cusers.zeppelin.apache.org%3E","https://zeppelin.apache.org/releases/zeppelin-release-0.7.3.html"],"refmap":{"bid":["108050"],"misc":["https://zeppelin.apache.org/releases/zeppelin-release-0.7.3.html"],"mlist":["[oss-security] 20190423 Issues fixed in previous releases of Apache Zeppelin 0.7.3 and 0.8.0 (CVE-2017-12619 CVE-2018-1317 CVE-2018-1328)","[zeppelin-users] 20190423 Issues fixed in previous releases of Apache Zeppelin 0.7.3 and 0.8.0 (CVE-2017-12619 CVE-2018-1317 CVE-2018-1328)"]},"summary":"Apache Zeppelin prior to 0.7.3 was vulnerable to session fixation which allowed an attacker to hijack a valid user session. Issue was reported by \"stone lone\".","vulnerable_configuration":[{"id":"cpe:2.3:a:apache:zeppelin:0.6.1:*:*:*:*:*:*:*","title":"cpe:2.3:a:apache:zeppelin:0.6.1:*:*:*:*:*:*:*"},{"id":"cpe:2.3:a:apache:zeppelin:0.6.2:*:*:*:*:*:*:*","title":"cpe:2.3:a:apache:zeppelin:0.6.2:*:*:*:*:*:*:*"},{"id":"cpe:2.3:a:apache:zeppelin:0.7.2:*:*:*:*:*:*:*","title":"cpe:2.3:a:apache:zeppelin:0.7.2:*:*:*:*:*:*:*"}],"vulnerable_configuration_cpe_2_2":[],"vulnerable_product":["cpe:2.3:a:apache:zeppelin:0.6.1:*:*:*:*:*:*:*","cpe:2.3:a:apache:zeppelin:0.6.2:*:*:*:*:*:*:*","cpe:2.3:a:apache:zeppelin:0.7.2:*:*:*:*:*:*:*"]}