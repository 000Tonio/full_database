{"Modified":"2019-10-09T23:21:00","Published":"2018-06-04T19:29:00","access":{"authentication":"NONE","complexity":"MEDIUM","vector":"NETWORK"},"assigner":"cve@mitre.org","capec":[{"id":"21","name":"Exploitation of Trusted Credentials","prerequisites":"Server software must rely on weak session IDs proof and/or verification schemes","related_weakness":["290","302","346","384","539","6","602","642","664"],"solutions":"Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit. Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens. Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted. Design: Use strong session identifiers that are protected in transit and at rest. Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated. Implementation: Verify of authenticity of all session IDs at runtime.","summary":"Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes \"trust\" other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system."},{"id":"31","name":"Accessing/Intercepting/Modifying HTTP Cookies","prerequisites":"Target server software must be a HTTP daemon that relies on cookies. The cookies must contain sensitive information. The adversary must be able to make HTTP requests to the server, and the cookie must be contained in the reply.","related_weakness":["113","20","302","311","315","384","472","539","565","602","642","724"],"solutions":"Design: Use input validation for cookies Design: Generate and validate MAC for cookies Implementation: Use SSL/TLS to protect cookie in transit Implementation: Ensure the web server implements all relevant security patches, many exploitable buffer overflows are fixed in patches issued for the software.","summary":"This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems. There are several different forms of this attack. The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein. The second form involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the adversary to impersonate the remote user/session. The third form is when the cookie's content is modified by the adversary before it is sent back to the server. Here the adversary seeks to convince the target server to operate on this falsified information."}],"cvss":4.3,"cvss-time":"2019-10-09T23:21:00","cvss-vector":"AV:N/AC:M/Au:N/C:N/I:P/A:N","cwe":"CWE-642","id":"CVE-2017-0928","impact":{"availability":"NONE","confidentiality":"NONE","integrity":"PARTIAL"},"last-modified":"2019-10-09T23:21:00","references":["https://github.com/guardian/html-janitor/issues/35","https://hackerone.com/reports/308158"],"refmap":{"misc":["https://github.com/guardian/html-janitor/issues/35","https://hackerone.com/reports/308158"]},"summary":"html-janitor node module suffers from an External Control of Critical State Data vulnerability via user-control of the '_sanitized' variable causing sanitization to be bypassed.","vulnerable_configuration":[{"id":"cpe:2.3:a:theguardian:html-janitor:2.0.2:*:*:*:*:node.js:*:*","title":"cpe:2.3:a:theguardian:html-janitor:2.0.2:*:*:*:*:node.js:*:*"}],"vulnerable_configuration_cpe_2_2":[],"vulnerable_product":["cpe:2.3:a:theguardian:html-janitor:2.0.2:*:*:*:*:node.js:*:*"]}