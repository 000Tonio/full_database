{"Modified":"2022-06-06T15:28:00","Published":"2022-05-24T16:15:00","access":{"authentication":"NONE","complexity":"LOW","vector":"NETWORK"},"assigner":"security-advisories@github.com","capec":[{"id":"68","name":"Subvert Code-signing Facilities","prerequisites":"A framework-based language that supports code signing (such as, and most commonly, Java or .NET) Deployed code that has been signed by its authoring vendor, or a partner. The attacker will, for most circumstances, also need to be able to place code in the victim container. This does not necessarily mean that they will have to subvert host-level security, except when explicitly indicated.","related_weakness":["325","328"],"solutions":"A given code signing scheme may be fallible due to improper use of cryptography. Developers must never roll out their own cryptography, nor should existing primitives be modified or ignored. If an attacker cannot attack the scheme directly, he might try to alter the environment that affects the signing and verification processes. A possible mitigation is to avoid reliance on flags or environment variables that are user-controllable.","summary":"Many languages use code signing facilities to vouch for code's identity and to thus tie code to its assigned privileges within an environment. Subverting this mechanism can be instrumental in an attacker escalating privilege. Any means of subverting the way that a virtual machine enforces code signing classifies for this style of attack."},{"id":"461","name":"Web Services API Signature Forgery Leveraging Hash Function Extension Weakness","prerequisites":"Web services check the signature of the API calls Authentication tokens / secrets are shared between the server and the legitimate client The API call signature is generated by concatenating the parameter list with the shared secret and hashing the result. An iterative hash function like MD5 and SHA1 is used. An attacker is able to intercept or in some other way gain access to the information passed between the legitimate client and the server in order to retrieve the hash value and length of the original message. The communication channel between the client and the server is not secured via channel security such as TLS","related_weakness":["290","328"],"solutions":"Design: Use a secure message authentication code (MAC) function such as an HMAC-SHA1","summary":"When web services require callees to authenticate, they sometimes issue a token / secret to the caller that the caller is to use to sign their web service calls. In one such scheme the caller when constructing a request would concatenate all of the parameters passed to the web service with the provided authentication token and then generate a hash of the concatenated string (e.g., MD5, SHA1, etc.). That hash then forms the signature that is passed to the web service which is used on the server side to verify the origin authenticity and integrity of the message. There is a practical attack against an authentication scheme of this nature that makes use of the hash function extension / padding weakness. Leveraging this weakness, an attacker, who does not know the secret token, is able to modify the parameters passed to the web service by generating their own call and still generate a legitimate signature hash. For instance, consider the message to be passed to the web service is M (this message includes the parameters passed to the web service concatenated with the secret token / key bytes). The message M is hashed and that hash is passed to the web service and is used for authentication. The attacker does not know M, but can see Hash (M) and Length (M). The attacker can then compute Hash (M || Padding (M) || M') for any M'. The attacker does not know the entire message M, specifically the attacker does not know the secret bytes, but that does not matter. The attacker is still able to sign their own message M' and make the called web service verify the integrity of the message without an error. Because of the iterative design of the hash function, it is possible, from only the hash of a message and its length, to compute the hash of longer messages that start with the initial message and include the padding required for the initial message to reach a multiple of 512 bits. It is important to note that the attack not limited to MD5 and will work just as well with another hash function like SHA1."}],"cvss":5,"cvss-time":"2022-06-06T15:28:00","cvss-vector":"AV:N/AC:L/Au:N/C:P/I:N/A:N","cwe":"CWE-328","id":"CVE-2022-29249","impact":{"availability":"NONE","confidentiality":"PARTIAL","integrity":"NONE"},"last-modified":"2022-06-06T15:28:00","references":["https://github.com/JavaEZLib/JavaEZ/security/advisories/GHSA-67fj-6w6m-w5j8","https://github.com/JavaEZLib/JavaEZ/releases/tag/1.7"],"summary":"JavaEZ is a library that adds new functions to make Java easier. A weakness in JavaEZ 1.6 allows force decryption of locked text by unauthorized actors. The issue is NOT critical for non-secure applications, however may be critical in a situation where the highest levels of security are required. This issue ONLY affects v1.6 and does not affect anything pre-1.6. The vulnerability has been patched in release 1.7. Currently, there is no way to fix the issue without upgrading.","vulnerable_configuration":[{"id":"cpe:2.3:a:javaez_project:javaez:1.6:*:*:*:*:*:*:*","title":"cpe:2.3:a:javaez_project:javaez:1.6:*:*:*:*:*:*:*"}],"vulnerable_configuration_cpe_2_2":[],"vulnerable_product":["cpe:2.3:a:javaez_project:javaez:1.6:*:*:*:*:*:*:*"]}